---
########################################################################################################################
#- hosts: localhost
#  vars:
#    ec2_region: eu-central-1
#    ec2_instance_type: t2.large
#    ec2_instance_count: 1
#    ec2_enabled: yes
#    ec2_key_name: ec2-mcp-core
#  tasks:
#
#  - block:
#    - name: EC2 | Install Boto library
#      pip:
#        name: boto3
#        state: latest
#        extra_args: --user --upgrade
#      when: ec2_enabled
#      tags: [ec2, boto]
#
#    - name: EC2 | Create keypair
#      ec2_key:
#        name: '{{ ec2_key_name }}'
#        key_material: '{{ item }}'
#        region: '{{ ec2_region }}'
#      with_file: '{{ ansible_env.HOME }}/.ssh/ec2.centos.pub'
#      when: ec2_enabled
#      tags: [ec2, keypair]
#
#    - name: EC2 | Configure security groups for mobile-core
#      ec2_group:
#        name: '{{ item.name }}'
#        description: '{{ item.description}}'
#        region: '{{ ec2_region }}'
#        rules:
#          - proto: '{{ item.proto }}'
#            from_port: '{{ item.port }}'
#            to_port: '{{ item.port }}'
#            cidr_ip: 0.0.0.0/0
#      with_items:
#        - {name: mcore-ssh,   description: Allow SSH access,   proto: tcp, port: 22}
#        - {name: mcore-https, description: Allow HTTPS access, proto: tcp, port: 8443}
#      tags: [ec2, security]
#
#    - name: EC2 | Outbound security group
#      ec2_group:
#        name: outbound
#        description: allow outbound connections to the internet
#        region: "{{ ec2_region }}"
#        rules_egress:
#          - proto: all
#            cidr_ip: 0.0.0.0/0
#      tags: [ec2, security]
#
#    - name: EC2 | Get the Centos EBS SSD AMI
#      ec2_ami_find:
#        architecture: x86_64
#        name: 'CentOS Linux 7*EBS*'
#        region: '{{ ec2_region }}'
#        sort: creationDate
#        sort_order: descending
#        sort_end: 1
#        no_result_action: fail
#      register: centos_ami_find
#      tags: [ec2, find-vmi]
#
#    - name: EC2 | Start the instances
#      ec2:
#        region: '{{ ec2_region }}'
#        image: '{{ centos_ami_find.results[0].ami_id }}'
#        instance_type: '{{ ec2_instance_type }}'
#        key_name: '{{ ec2_key_name }}'
#        group: [ssh, https, outbound]
#        instance_tags: {Name: mcore-1, type: mobile-core, env: testing}
#        exact_count: '{{ ec2_instance_count }}'
#        count_tag: {type: mobile-core}
#        wait: yes
#      register: ec2
#      tags: [ec2, start-vms]
#
#    - name: EC2 | Add instances to group
#      add_host:
#        hostname: '{{ item.public_dns_name }}'
#        groups: mcore
#      with_items: '{{ ec2.tagged_instances }}'
#      when: item.public_dns_name is defined
#      tags: [ec2, group-vms]
#
#    - name: EC2 | Wait for SSH server to be running
#      wait_for:
#        host: '{{ item.public_dns_name }}'
#        port: 22
#        search_regex: OpenSSH
#      with_items: '{{ ec2.tagged_instances }}'
#      when: item.public_dns_name is defined
#      tags: [ec2, wait-vms]
#
########################################################################################################################
- hosts: centos
  vars:
    pip_version: '9.0.1'
    oc_version: '3.7.1'
    oc_sha: 'ab0f056'
    nvm_version: '0.33.8'
    nodejs_version: '6.12.3'
    resolv_nameservers:
      - 192.168.64.1
      - 8.8.8.8
      - 8.8.4.4
  tasks:

######################### SYSTEM
  - block:
    - name: System | Upgrade all packages
      yum:
        name: '*'
        state: latest
      become: yes
      tags: [system, install]

    - name: System | Install required packages
      yum:
        name: '{{ item }}'
        state: latest
      with_items:
        - curl
        - epel-release
        - git
        - libselinux-python
        - mc
        - ntp
        - net-tools
        - unzip
        - vim
        - wget
        - zip
      become: yes
      tags: [system, packages]

    - name: System | Ensure the NTP service active and enabled
      systemd:
        name: ntpd
        state: started
        enabled: yes
      become: yes
      tags: [system, service]

    - name: System | Configure resolv.conf
      template:
        src: resolv.conf.j2
        dest: /etc/resolv.conf
        mode: 0644
      become: yes
      tags: [system, nameserver]

######################### PIP, meta: require: system
  - name: Pip | Install the latest version of python-pip
    yum:
      name: python-pip
      state: latest
    become: yes
    tags: [pip, install]

  - name: Pip | Install latest version
    pip:
      name: pip
      state: latest
      extra_args: --upgrade
    become: yes
    tags: [pip, install]

  # POSTCHECK pip block
  - name: Pip | Check installed version
    shell: /usr/bin/test "$(pip --version | awk '{print $2}' 2> /dev/null)" = {{ pip_version }}
    ignore_errors: yes
    changed_when: false
    register: pip_wanted_version_installed
    failed_when: pip_wanted_version_installed.rc > 0
    tags: [pip, install]

  - debug: var=pip_wanted_version_installed

######################### ANSIBLE, meta: require pip
  - name: Ansible | Install latest ansible with pip
    pip:
      name: ansible
      state: latest
      extra_args: --user --upgrade
    when: pip_wanted_version_installed.rc == 0
    tags: [ansible, install]

######################### DOCKER, meta: require: system
  - name: Docker | Get the current users name
    shell: id -u -n
    changed_when: false
    ignore_errors: '{{ ansible_check_mode }}'
    register: user_name

  - block:
    - name: Docker | Install latest docker version
      shell: curl -fsSL https://get.docker.com/ | sh
      changed_when: false
      ignore_errors: '{{ ansible_check_mode }}'
      register: docker_installation
      tags: [docker, install]

    - name: Docker | Enable system service
      systemd:
        name: docker
        state: started
        enabled: yes
      become: yes
      tags: [docker, service]

    - name: Docker | Add {{ user_name.stdout }} to docker group
      user:
        name: '{{ user_name.stdout }}'
        group: docker
        append: yes
      become: yes
      tags: [docker, install]

    - name: Docker | Add insecure registry to sysconfig
      lineinfile:
        path: /etc/sysconfig/docker
        create: yes
        state: present
        line: OPTIONS='--selinux-enabled --insecure-registry 172.30.0.0/16'
      become: yes
      tags: [docker, config]

    - name: Docker | Adding insecure registry to daemon
      template:
        src: daemon.json.j2
        dest: /etc/docker/daemon.json
        mode: 0644
      become: yes
      tags: [docker, install]
    always:
      - debug: msg="trigger docker restart"
        notify: docker restart
        changed_when: true
        tags: [docker, install]

  # POSTCHECK docker block
  - name: Docker | Check bridge network
    command: docker network inspect -f '{% raw %}{{range .IPAM.Config }}{{ .Subnet }}{{end}}{% endraw %}' bridge
    changed_when: false
    ignore_errors: '{{ ansible_check_mode }}'
    register: docker_bridge
    become: yes
    tags: [docker, check]

  - debug: var=docker_bridge
    tags: [docker, check]

######################### FIREWALLD, meta: require: system
  - name: Firewall | Enable firewalld
    systemd:
      name: firewalld
      state: started
      enabled: yes
    become: yes
    tags: [firewall, service]

  - name: Firewall | Check dockerc firewall zone exists
    command: firewall-cmd --info-zone=dockerc
    changed_when: false
    ignore_errors: yes
    register: dockerc_zone_exists
    become: yes
    tags: [firewalld, config]

  - debug: var=dockerc_zone_exists
    tags: [firewall, config]

  - block:
    - name: Firewall | Add dockerc zone
      command: firewall-cmd --permanent --new-zone dockerc
      failed_when: false
      changed_when: false
      ignore_errors: '{{ ansible_check_mode }}'
      when: dockerc_zone_exists.rc != 0
      become: yes
      tags: [firewall, config]

    - name: Firewall | Open ports in dockerc zone
      firewalld:
        zone: dockerc
        permanent: yes
        source: 172.17.0.0/16
        state: enabled
        port: '{{ item }}'
      with_items:
        - '8443/tcp'
        - '53/udp'
        - '8053/udp'
      become: yes
      tags: [firewall, config]
    always:
      - debug: msg="trigger firewalld reload"
        notify: firewalld reload
        changed_when: true

######################### OC, meta: require: system
  - name: OC | Get the current users name
    shell: id -u -n
    changed_when: false
    ignore_errors: '{{ ansible_check_mode }}'
    register: user_name

  # PREREQUISITE BLOCK
  - name: OC | Check  if OC@{{ oc_version }} is already installed
    stat:
      path: $OC_DIR/v{{ oc_version }}/oc
    ignore_errors: yes
    changed_when: false
    register: oc_bin_installed
    environment:
      OC_DIR: "/opt/openshift/oc"

  ## OC block
  - when: not oc_bin_installed.stat.exists
    block:
    - name: OC | Create temporary directory
      tempfile:
        state: directory
        prefix: oc
      changed_when: false
      register: oc_dir_tmp
      tags: [oc, install]

    - name: OC | Download OC bundle TAR.GZ
      get_url:
        url: 'https://github.com/openshift/origin/releases/download/v{{ oc_version }}/openshift-origin-client-tools-v{{ oc_version }}-{{ oc_sha }}-linux-64bit.tar.gz'
        dest: '{{ oc_dir_tmp.path }}/'
      when: not oc_dir_tmp|skipped
      register: oc_download
      tags: [oc, install]

    - name: OC | Create OC installation directory
      file:
        path: '/opt/openshift/oc/v{{ oc_version }}'
        state: directory
        owner: '{{ user_name.stdout }}'
      when: not oc_download|skipped
      become: yes
      tags: [oc, install]

    - name: OC | Extract OC bundle TAR.GZ
      unarchive:
        src: '{{ oc_dir_tmp.path }}/openshift-origin-client-tools-v{{ oc_version }}-{{ oc_sha }}-linux-64bit.tar.gz'
        dest: '/opt/openshift/oc/v{{ oc_version }}'
        owner: '{{ user_name.stdout }}'
        copy: no
        extra_opts: --strip-components=1
      when: not oc_download|skipped
      register: oc_bundle_extract
      become: yes
      tags: [oc, install]

    - name: OC | Sym link {{ oc_installation_dir }} to OC latest
      file:
        src: '/opt/openshift/oc/v{{ oc_version }}'
        dest: '/opt/openshift/oc/latest'
        state: link
        force: yes
      when: not oc_bundle_extract|skipped
      register: oc_latest_opt_dir
      tags: [oc, install]

    - name: OC | Sym link /usr/local/bin/oc to OC latest
      file:
        src: '/opt/openshift/oc/latest/oc'
        dest: '/usr/local/bin/oc'
        state: link
        force: yes
      when: not oc_latest_opt_dir|skipped
      become: yes
      tags: [oc, install]

    always:
      - name: OC | Cleanup TMP directory
        file:
          name: '{{ oc_dir_tmp.path }}'
          state: absent
        changed_when: false
        ignore_errors: '{{ ansible_check_mode }}'
        tags: [oc, install]

  # POSTCHECK for OC client version installed
  - name: OC | Checking installed version of OC client
    shell: /usr/bin/test "$(oc version | head -n1 | awk '{print $2}' 2> /dev/null)" = v{{ oc_version }}+{{ oc_sha }}
    ignore_errors: yes
    register: oc_wanted_version_installed
    failed_when: oc_wanted_version_installed.rc > 0
    tags: [oc, check]

######################## NVM, meta: require: system
  # PREREQUISITE BLOCK
  - name: NodeJs | Check if NodeJs@{{ nodejs_version }} is installed
    stat:
      path: $NVM_DIR/versions/node/v{{ nodejs_version }}/bin/node
    ignore_errors: yes
    changed_when: false
    register: nodejs_bin_installed
    environment:
      NVM_DIR: "{{ ansible_env.HOME }}/.nvm"
    tags: [nodejs, install]

  - when: not nodejs_bin_installed.stat.exists
    block:
    - name: NodeJs | Install NVM@{{ nvm_version }}
      shell: curl -fsSL https://raw.githubusercontent.com/creationix/nvm/v{{ nvm_version }}/install.sh | sh
      args:
        creates: $NVM_DIR/nvm.sh
      ignore_errors: '{{ ansible_check_mode }}'
      register: nvm_installed
      environment:
        NVM_DIR: '{{ ansible_env.HOME }}/.nvm'
      tags: [nvm, install]

    - name: NodeJs| NVM install NodeJs@{{ nodejs_version }}
      shell: source $NVM_DIR/nvm.sh && nvm install v{{ nodejs_version }}
      when: not nvm_installed|skipped
      environment:
        NVM_DIR: '{{ ansible_env.HOME }}/.nvm'
      tags: [nodejs, install]

    - name: NodeJs | NVM set NodeJs@{{ nodejs_version }} as default
      shell: source $NVM_DIR/nvm.sh && nvm alias default v{{ nodejs_version }}
      when: not nvm_installed|skipped
      environment:
        NVM_DIR: '{{ ansible_env.HOME }}/.nvm'
      tags: [nodejs, install]

  # POSTCHECK BLOCK
  - name: NodeJs | Check installed version
    shell: /usr/bin/test "$(node -v 2> /dev/null)" = v{{ nodejs_version }}
    register: nodejs_wanted_version_installed
    failed_when: nodejs_wanted_version_installed.rc > 0
    tags: [nodejs, check]

######################### MOBILE CORE, meta: require: ansible
  - name: MCore | Get the current users name
    shell: id -u -n
    changed_when: false
    ignore_errors: '{{ ansible_check_mode }}'
    register: user_name
    tags: [mcore, clone]

  - name: MCore | Clone mobile-core repo in /home/{{ user_name.stdout }}
    git:
      repo: https://github.com/aerogear/mobile-core
      dest: /home/{{ user_name.stdout }}/mobile-core
      refspec: '+refs/pull/*:refs/heads/*'
    register: mobile_core_cloned
    tags: [mcore, clone]

  - name: MCore | Ansible galaxy install
    command: ansible-galaxy install -r installer/requirements.yml
    args:
      chdir: '/home/{{ user_name.stdout }}/mobile-core'
    environment:
      PATH: "{{ ansible_env.PATH}}:/home/{{ user_name.stdout }}/.local/bin"
    changed_when: mobile_core_cloned.changed
    failed_when: mobile_core_cloned.failed
    tags: [mcore, install]

#  - name: Ansible playbook run
#    command: >
#      ansible-playbook installer/playbook.yml
#      -e "dockerhub_username=$DOCKERHUB_USERNAME"
#      -e "dockerhub_password=$DOCKERHUB_PASSWORD"
#    args:
#      chdir: "~/mobile-core"
#    environment:
#      PATH: "{{ ansible_env.PATH}}:/home/{{ ansible_user }}/.local/bin"
#    changed_when: false
#    ignore_errors: '{{ ansible_check_mode }}'

  handlers:
    - name: docker restart
      systemd:
        state: restarted
        daemon_reload: yes
        name: docker
      become: yes
      tags: [docker, config]

    - name: firewalld reload
      command: firewall-cmd --reload
      changed_when: false
      ignore_errors: '{{ ansible_check_mode }}'
      become: yes
      tags: [firewalld, config]

# TODO check if we need setup cluster up with AWS EC2 instance
#$ metadata_endpoint="http://169.254.169.254/latest/meta-data"
#$ public_hostname="$( curl "${metadata_endpoint}/public-hostname" )"
#$ public_ip="$( curl "${metadata_endpoint}/public-ipv4" )"
#$ oc cluster up --public-hostname="${public_hostname}" --routing-suffix="${public_ip}.nip.io"
